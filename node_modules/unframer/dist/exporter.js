"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundle = bundle;
exports.resolvePackage = resolvePackage;
exports.checkUnframerVersion = checkUnframerVersion;
exports.getDarkModeSelector = getDarkModeSelector;
exports.getStyleTokensCss = getStyleTokensCss;
exports.findRelativeLinks = findRelativeLinks;
exports.extractPropControlsUnsafe = extractPropControlsUnsafe;
exports.propControlsToType = propControlsToType;
exports.parsePropertyControls = parsePropertyControls;
exports.extractTokenInfo = extractTokenInfo;
exports.componentCamelCase = componentCamelCase;
exports.createExampleComponentCode = createExampleComponentCode;
const esbuild_1 = require("esbuild");
const package_json_1 = __importDefault(require("../package.json"));
const url_1 = __importDefault(require("url"));
const async_sema_1 = require("async-sema");
const esbuild_plugins_node_modules_polyfill_1 = require("esbuild-plugins-node-modules-polyfill");
const core_1 = require("@babel/core");
const child_process_1 = require("child_process");
const console_1 = require("console");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const utils_js_1 = require("./utils.js");
const babel_jsx_js_1 = require("./babel-jsx.js");
const compat_js_1 = require("./compat.js");
const css_js_1 = require("./css.js");
const esbuild_2 = require("./esbuild");
const framer_js_1 = require("./framer.js");
const sentry_1 = require("./sentry");
const utils_js_2 = require("./utils.js");
const js_api_1 = require("@biomejs/js-api");
let biome;
async function bundle({ config, cwd: out = '', watch = false, signal = undefined, }) {
    const { components, breakpoints, tokens, framerWebPages } = config;
    out ||= path_1.default.resolve(process.cwd(), 'example');
    out = path_1.default.resolve(out);
    try {
        await fs_1.default.promises.mkdir(out, { recursive: true });
    }
    catch (e) { }
    utils_js_2.spinner.start('exporting components...');
    const otherRoutes = Object.fromEntries((config.framerWebPages || []).map((page) => [
        page.webPageId,
        { path: page.path },
    ]));
    const breakpointSizes = Object.entries(config.breakpoints || css_js_1.defaultBreakpointSizes).sort(([, a], [, b]) => a - b);
    function fakeContext(args) {
        return {
            rebuild() {
                return (0, esbuild_1.build)(args);
            },
            cancel() { },
            dispose() { },
        };
    }
    const fn = watch ? esbuild_1.context : fakeContext;
    let foundError = false;
    const buildContext = await fn({
        absWorkingDir: out,
        entryPoints: Object.keys(components)
            .filter((x) => x)
            .map((name) => {
            return {
                in: `virtual:${name}`,
                out: name,
            };
        }),
        jsx: 'automatic',
        // jsxFactory: '_jsx',
        bundle: true,
        platform: 'browser',
        metafile: true,
        format: 'esm',
        minify: false,
        treeShaking: true,
        splitting: true,
        logLevel: 'error',
        pure: ['addPropertyControls'],
        external: esbuild_2.defaultExternalPackages,
        chunkNames: 'chunks/[name]-[hash]',
        plugins: [
            (0, esbuild_2.esbuildPluginBundleDependencies)({
                signal,
                externalPackages: config.externalPackages,
                externalizeNpm: config.allExternal,
                outDir: config.outDir,
                onMissingPackage: (e) => {
                    foundError = true;
                },
            }),
            (0, esbuild_plugins_node_modules_polyfill_1.nodeModulesPolyfillPlugin)({}),
            {
                name: 'virtual loader',
                setup(build) {
                    build.onResolve({ filter: /^virtual:.*/ }, (args) => {
                        return {
                            path: args.path.replace(/^virtual:/, ''),
                            namespace: 'virtual',
                        };
                    });
                    build.onLoad({ filter: /.*/, namespace: 'virtual' }, async (args) => {
                        const name = args.path;
                        const url = components[name];
                        const componentBreakpoints = config.componentBreakpoints?.filter((x) => x.componentName === name) || [];
                        const brk = breakpointSizes
                            .map(([name, width], index) => {
                            const nextWidth = breakpointSizes[index + 1]?.[1] ??
                                Infinity;
                            const matchingBreakpoint = componentBreakpoints.find((x) => x.width >= width &&
                                x.width < nextWidth);
                            if (!matchingBreakpoint) {
                                return [];
                            }
                            return [name, matchingBreakpoint.variantId];
                        })
                            .filter((x) => x.length);
                        const firstVariantId = brk.find((x) => x.length)?.[1];
                        const responsiveVariants = firstVariantId
                            ? Object.fromEntries([
                                ['base', firstVariantId],
                                ...brk.slice(1),
                            ])
                            : {};
                        return {
                            contents: /** js **/ `
                                'use client'
                                import { Fragment } from 'react'
                                import { ContextProviders } from 'unframer'
                                import Component from '${await (0, esbuild_2.resolveRedirect)({
                                url,
                                signal,
                            })}'
                                import { WithFramerBreakpoints } from 'unframer'
                                const locales = ${JSON.stringify(config.locales) || '[]'}
                                const defaultResponsiveVariants = ${JSON.stringify(responsiveVariants, null, 2)}

                                Component.Responsive = ({ locale, ...rest }) => {
                                    return (
                                        <ContextProviders
                                            routes={${JSON.stringify(otherRoutes)}}
                                            children={<WithFramerBreakpoints
                                                        Component={Component}
                                                        variants={defaultResponsiveVariants}
                                                        {...rest}
                                                    />}
                                            framerSiteId={${JSON.stringify(config.fullFramerProjectId)}}
                                            locale={locale}
                                            locales={locales}
                                        />
                                    )
                                }

                                export default function ComponentWithRoot({ locale, ...rest }) {
                                    return (
                                        <ContextProviders
                                            routes={${JSON.stringify(otherRoutes, null, 2)}}
                                            children={<Component {...rest} />}
                                            framerSiteId={${JSON.stringify(config.fullFramerProjectId)}}
                                            locale={locale}
                                            locales={locales}
                                        />
                                    )
                                }
                                Object.assign(ComponentWithRoot, Component)
                                `,
                            loader: 'jsx',
                        };
                    });
                },
            },
        ],
        write: false,
        outdir: out,
    });
    const doNotEditComment = `/* This file was generated by Unframer for Framer project ${config.projectId || ''} "${config.projectName}", do not edit manually */\n`;
    async function rebuild() {
        const prevFiles = await recursiveReaddir(out);
        const buildResult = await buildContext.rebuild().catch((e) => {
            if (e.message.includes('No matching export ')) {
                foundError = true;
                utils_js_2.spinner.error(`esbuild failed to import from an external package, this usually means that the npm package version in Framer is older than the latest.`);
                utils_js_2.spinner.error(`Use --external to make all npm packagess external, then install the right version`);
                process.exit(1);
            }
            throw e;
        });
        utils_js_2.spinner.update('Finished build');
        for (let file of buildResult.outputFiles) {
            const resultPathAbsJs = path_1.default.resolve(out, file.path);
            const resultPathAbsJsx = resultPathAbsJs.replace(/\.js$/, '.jsx');
            const existing = await fs_1.default.promises
                .readFile(resultPathAbsJsx, 'utf-8')
                .catch(() => null);
            const tooBigSize = 0.7 * 1024 * 1024;
            let formatted = file.text;
            let tooBig = file.text.length >= tooBigSize;
            let didFormat = false;
            if (config.jsx &&
                !tooBig &&
                !resultPathAbsJs.includes('/chunks/') &&
                !resultPathAbsJs.includes('\\chunks\\')) {
                try {
                    let res = (0, core_1.transform)(file.text || '', {
                        babelrc: false,
                        sourceType: 'module',
                        plugins: [
                            // babelPluginDeduplicateImports,
                            babel_jsx_js_1.babelPluginJsxTransform,
                            babel_jsx_js_1.removeJsxExpressionContainer,
                        ],
                        // ast: true,
                        // code: false,
                        filename: 'x.jsx',
                        compact: false,
                        sourceMaps: false,
                    });
                    if (res?.code) {
                        if (!biome) {
                            biome = await js_api_1.Biome.create({
                                distribution: js_api_1.Distribution.NODE,
                            });
                        }
                        let result = biome.formatContent(res.code, {
                            filePath: 'example.jsx',
                        });
                        didFormat = true;
                        formatted = result.content;
                    }
                }
                catch (e) {
                    (0, sentry_1.notifyError)(e, 'babel transform and format');
                }
            }
            // let inputCode = res!.code!
            // let shouldFormat = !tooBig && !file.path.includes('chunks')
            // if (shouldFormat) {
            //     spinner.update(`Formatting ${path.relative(out, file.path)}`)
            //     formatted = dprint.format('file.jsx', file.text, {
            //         lineWidth: 140,
            //         quoteStyle: 'alwaysSingle',
            //         trailingCommas: 'always',
            //         semiColons: 'always',
            //     })
            // }
            // if (tooBig) {
            //     spinner.info(
            //         `skipping formatting ${path.relative(
            //             out,
            //             file.path,
            //         )}, too big`,
            //     )
            // }
            // if (framerWebPages?.length) {
            //     codeNew = replaceWebPageIds({
            //         code: codeNew,
            //         elements: framerWebPages,
            //     })
            // }
            // const lines = findRelativeLinks(codeNew)
            // if (lines.length) {
            //     spinner.error(
            //         `found broken links for ${path.relative(out, file.path)}`,
            //     )
            //     lines.forEach((line) => {
            //         logger.log(`${path.resolve(out, file.path)}:${line + 1}`)
            //     })
            // }
            const prefix = `// @ts-nocheck\n` + `/* eslint-disable */\n` + doNotEditComment;
            const codeJsx = prefix + formatted;
            const codeJs = prefix + file.text;
            // if (existing === codeJsx) {
            //     continue
            // }
            utils_js_2.logger.log(`writing`, path_1.default.relative(out, file.path));
            await fs_1.default.promises.mkdir(path_1.default.dirname(resultPathAbsJsx), {
                recursive: true,
            });
            if (codeJs !== codeJsx || !didFormat) {
                await fs_1.default.promises.writeFile(resultPathAbsJs, codeJs, 'utf-8');
            }
            if (didFormat) {
                await fs_1.default.promises.writeFile(resultPathAbsJsx, codeJsx, 'utf-8');
            }
        }
        utils_js_2.spinner.stop();
        await fs_1.default.promises.writeFile(path_1.default.resolve(out, '.cursorignore'), `**/*.js\nchunks\n`, 'utf-8');
        if (!buildResult?.outputFiles) {
            throw new Error('Failed to generate result');
        }
        const packageJson = path_1.default.resolve(out, 'package.json');
        await fs_1.default.promises.writeFile(packageJson, JSON.stringify({ type: 'module' }), 'utf-8');
        const sema = new async_sema_1.Sema(utils_js_2.stackblitzDemoExample ? 5 : 6);
        utils_js_2.spinner.update('Extracting types');
        utils_js_2.logger.log(`using node path`, nodePath);
        let allFonts = [];
        const propControlsData = await Promise.all(buildResult?.outputFiles.map(async (file) => {
            try {
                await sema.acquire();
                const name = path_1.default
                    .relative(out, file.path)
                    .replace(/\.jsx?$/, '');
                const resultPathAbs = path_1.default.resolve(out, file.path);
                if (!components[name]) {
                    return;
                }
                if (!fs_1.default.existsSync(resultPathAbs)) {
                    utils_js_2.spinner.error(`cannot extract types for ${name}, missing output file`);
                    return;
                }
                utils_js_2.logger.log(`extracting types for ${name}`);
                utils_js_2.spinner.update(`Extracting types for ${name}`);
                const { propertyControls, fonts } = await extractPropControlsUnsafe(resultPathAbs, name);
                if (!propertyControls) {
                    utils_js_2.logger.log(`no property controls found for ${name}`);
                }
                allFonts.push(...(fonts || []).map((x) => ({
                    ...x,
                    fileName: path_1.default.basename(file.path),
                })));
                const types = propControlsToType({
                    controls: propertyControls,
                    fileName: name,
                    config,
                });
                await fs_1.default.promises.mkdir(out, { recursive: true });
                await fs_1.default.promises.writeFile(path_1.default.resolve(out, `${name}.d.ts`), types);
                return {
                    propertyControls,
                    fonts,
                    name,
                };
            }
            finally {
                sema.release();
            }
        })).finally(async () => {
            try {
                await fs_1.default.promises.rm(packageJson);
            }
            catch (error) {
                // Ignore error if file doesn't exist or can't be deleted
            }
        });
        // spinner.stop()
        const cssString = doNotEditComment +
            '/* This css file has all the necessary styles to run all your components */\n' +
            '\n' +
            resetCssStyles +
            getStyleTokensCss(tokens || []) +
            (0, css_js_1.breakpointsStyles)(breakpoints) +
            '\n\n' +
            framer_js_1.combinedCSSRules
                .map((x) => (x?.startsWith('  ') ? (0, utils_js_1.dedent)(x) : x))
                .join('\n') +
            (0, css_js_1.getFontsStyles)(allFonts);
        await fs_1.default.promises.writeFile(path_1.default.resolve(out, 'styles.css'), cssString, 'utf-8');
        (0, css_js_1.logFontsUsage)(allFonts)
            ?.split('\n')
            .forEach((x) => utils_js_2.logger.log(x));
        const jsxFiles = buildResult.outputFiles
            .filter((x) => x.path.endsWith('.js') &&
            fs_1.default.existsSync(x.path.replace(/\.js$/, '.jsx')))
            .map((x) => x.path.replace(/\.js$/, '.jsx'));
        const outFiles = buildResult.outputFiles
            .map((x) => path_1.default.resolve(out, x.path))
            .concat([
            path_1.default.resolve(out, 'meta.json'),
            path_1.default.resolve(out, 'tokens.css'),
            path_1.default.resolve(out, '.cursorignore'),
            path_1.default.resolve(out, 'styles.css'),
        ])
            .concat(jsxFiles)
            .concat(buildResult.outputFiles.map((x) => path_1.default.resolve(out, x.path.replace(/\.jsx?$/, '.d.ts'))));
        const filesToDelete = prevFiles
            .filter((x) => !outFiles.includes(x))
            .concat(buildResult.outputFiles
            .map((x) => x.path)
            .filter((js) => js.endsWith('.js') &&
            jsxFiles.some((x) => x.startsWith(js))));
        for (let file of filesToDelete) {
            utils_js_2.logger.log('deleting', path_1.default.relative(out, file));
            try {
                await fs_1.default.promises.rm(file);
            }
            catch (error) {
                // Ignore error if file doesn't exist or can't be deleted
            }
        }
        await fs_1.default.promises.writeFile(path_1.default.resolve(out, 'meta.json'), JSON.stringify(buildResult.metafile, null, 2), 'utf-8');
        if (signal?.aborted) {
            throw new Error('aborted');
        }
        if (watch) {
            utils_js_2.logger.log('waiting for components or config changes');
        }
        if (!tokens?.length) {
            const tokensCss = "/* This css file contains your color variables, sometimes these get desynced when updated in Framer so it's good that you copy and paste this snippet into your app css */\n" +
                '/* Bug: https://www.framer.community/c/bugs/color-style-unlinks-when-copying-component-between-projects-resulting-in-potential-value-discrepancy */\n' +
                getTokensCss({ out, result: buildResult });
            await fs_1.default.promises.writeFile(path_1.default.resolve(out, 'tokens.css'), tokensCss, 'utf-8');
        }
        const res = {
            components: Object.entries(components).map(([name, v]) => {
                const propControls = propControlsData.find((x) => x?.name === name);
                return {
                    componentPathSlug: name,
                    url: v,
                    name,
                    componentName: componentCamelCase(name),
                    propertyControls: propControls?.propertyControls,
                };
            }),
        };
        utils_js_2.spinner.info(`Build completed`);
        return res;
    }
    // when user press ctrl+c dispose
    process.on('SIGINT', async () => {
        utils_js_2.spinner.stop();
        console.log();
        await buildContext.cancel();
        buildContext.dispose();
        process.exit(0); // Ensure process exits
    });
    process.on('SIGABRT', async () => {
        utils_js_2.spinner.stop();
        console.log();
        await buildContext.cancel();
        buildContext.dispose();
        process.exit(0); // Ensure process exits
    });
    signal?.addEventListener('abort', async () => {
        await buildContext.cancel();
        buildContext.dispose();
    });
    const result = await rebuild();
    console.log();
    console.log();
    const outDirForExample = path_1.default.posix.relative(process.cwd(), out).replace(/^src\//, '') ||
        'framer'; // remove src so file works inside src
    const { exampleCode } = await createExampleComponentCode({
        outDir: out,
        // buildResult: result,
        config,
    });
    if (utils_js_2.stackblitzDemoExample) {
        utils_js_2.logger.log(`Inside Stackblitz demo, writing App.tsx`);
        await fs_1.default.promises.mkdir(path_1.default.dirname(utils_js_2.stackblitzDemoExample), {
            recursive: true,
        });
        await fs_1.default.promises.writeFile(utils_js_2.stackblitzDemoExample, exampleCode);
    }
    if (!foundError) {
        console.log((0, utils_js_2.terminalMarkdown)((0, utils_js_1.dedent) `
        # How to use the Framer components

        Your components are exported to \`${outDirForExample}\` folder. Now please install the \`unframer\` runtime dependency:

        \`\`\`sh
        npm install unframer
        \`\`\`

        Each component has a \`.Responsive\` variant that allows you to specify different variants for different breakpoints.

        You can use the components like this (try copy pasting the code below into your React app):

        \`\`\`jsx
        ${exampleCode}
        \`\`\`

        It's very important to import the \`styles.css\` file to include the necessary styles for the components.

        To style components you can pass a \`style\` or \`className\` prop (but remember to use !important to increase the specificity).

        Read more on GitHub: https://github.com/remorses/unframer

        `));
    }
    await checkUnframerVersion({ cwd: out });
    console.log();
    return { result, rebuild, buildContext };
}
const packageVersionCache = new Map();
function resolvePackage({ cwd, pkg }) {
    if (packageVersionCache.has(pkg)) {
        return Promise.resolve(packageVersionCache.get(pkg));
    }
    return new Promise((resolve, reject) => {
        const code = `import('${pkg}/package.json', { with: { type: 'json' } }).then(pkg => console.log(pkg.version || pkg.default?.version));`;
        const command = [
            JSON.stringify(nodePath),
            '-e',
            JSON.stringify(code),
        ].join(' ');
        (0, child_process_1.exec)(command, {
            cwd,
        }, (error, stdout, stderr) => {
            if (error) {
                utils_js_2.logger.log(stderr);
                reject(new Error(`${pkg} is not installed in your project`));
                return;
            }
            const version = stdout.trim();
            packageVersionCache.set(pkg, version);
            resolve(version);
        });
    });
}
async function checkUnframerVersion({ cwd }) {
    const currentVersion = package_json_1.default.version;
    try {
        const installedVersion = await resolvePackage({ cwd, pkg: 'unframer' });
        if (installedVersion !== currentVersion) {
            utils_js_2.spinner.error(`IMPORTANT: Unframer version mismatch. Please run: npm update unframer@latest`);
        }
    }
    catch (e) {
        utils_js_2.spinner.error('IMPORTANT: Unframer is not installed in your project. Please run: npm install unframer');
    }
}
function getDarkModeSelector(opts) {
    const { darkModeType = 'class', content } = opts;
    if (darkModeType === 'media') {
        return ('@media (prefers-color-scheme: dark) {\n' +
            '    :root {\n' +
            content +
            '\n' +
            '    }\n' +
            '}');
    }
    return '.dark {\n' + content + '\n' + '}';
}
function getStyleTokensCss(tokens, darkModeType = 'class') {
    if (!tokens?.length) {
        return '';
    }
    const lightUnframerTokens = tokens
        .map((token) => '    --unframer-' +
        (0, utils_js_2.kebabCase)(token.name || token.id) +
        ': ' +
        token.lightColor +
        ';')
        .join('\n');
    const lightTokens = tokens
        .map((token) => '    --token-' + token.id + ': ' + token.lightColor + ';')
        .join('\n');
    const darkUnframerTokens = tokens
        .map((token) => '    --unframer-' +
        (0, utils_js_2.kebabCase)(token.name || token.id) +
        ': ' +
        token.darkColor +
        ';')
        .join('\n');
    const darkTokens = tokens
        .map((token) => '    --token-' + token.id + ': ' + token.darkColor + ';')
        .join('\n');
    return (':root {\n' +
        lightUnframerTokens +
        '\n\n' +
        lightTokens +
        '\n' +
        '}\n\n' +
        getDarkModeSelector({
            darkModeType,
            content: darkUnframerTokens + '\n\n' + darkTokens,
        }));
}
function findRelativeLinks(text) {
    const regex = /webPageId:\s+/g;
    const lines = text.split('\n');
    const lineNumbers = new Set();
    for (let i = 0; i < lines.length; i++) {
        if (regex.test(lines[i])) {
            lineNumbers.add(i);
        }
    }
    return [...lineNumbers];
}
async function extractPropControlsSafe(text, name) {
    try {
        const propControlsCode = await parsePropertyControls(text);
        // console.log('propControlsCode', propControlsCode)
        const propControls = await Promise.resolve().then(async () => {
            if (!propControlsCode)
                return;
            const ivm = require('isolated-vm');
            const vm = new ivm.Isolate({ memoryLimit: 128 });
            const vmContext = vm.createContextSync();
            const jail = vmContext.global;
            let result = undefined;
            vmContext.global.setSync('__return', (x) => {
                result = x;
            });
            const mod = vm.compileModuleSync(`${text}`);
            await mod.instantiateSync(vmContext, (spec, mod) => {
                // TODO instantiate framer, react, framer-motion etc
                return;
            });
            await mod.evaluate({});
            return result;
        });
        if (!propControls) {
            utils_js_2.logger.error(`no property controls found for component ${name}`);
            return;
        }
        return propControls;
    }
    catch (e) {
        (0, sentry_1.notifyError)(console_1.error, 'typescript generation error');
        utils_js_2.logger.error(`Cannot get property controls for ${name}`, e.stack);
    }
}
function getTokensCss({ out, result, }) {
    const allTokens = [];
    for (let file of result.outputFiles) {
        const code = fs_1.default.readFileSync(path_1.default.resolve(out, file.path), 'utf-8');
        const tokens = extractTokenInfo(code);
        // console.log('tokens', tokens)
        for (let token of tokens) {
            const already = allTokens.find((x) => x.tokenName === token.tokenName);
            const filePath = path_1.default.relative(out, file.path);
            const filePaths = (() => {
                if (!filePath.startsWith('chunk-')) {
                    return [filePath];
                }
                const files = Object.entries(result.metafile.outputs).filter(([k, v]) => {
                    const filename = path_1.default.basename(k);
                    if (filename.startsWith('chunk-')) {
                        return false;
                    }
                    const doesItImport = v.imports.find((x) => x.path === filePath);
                    return doesItImport;
                });
                return files.map(([k, v]) => k);
            })();
            if (!token?.tokenName?.startsWith('--token')) {
                continue;
            }
            if (!already) {
                allTokens.push({
                    tokenName: token.tokenName,
                    defaultValues: new Set([token.defaultValue]),
                    nameAnnotation: token.metadata?.name,
                    usedBy: new Set([...filePaths]),
                });
            }
            else {
                already.defaultValues.add(token.defaultValue);
                if (!already.nameAnnotation && token.metadata?.name) {
                    already.nameAnnotation = token.metadata.name;
                }
                filePaths.map((x) => already.usedBy.add(x));
            }
        }
    }
    const groupedByUsers = (0, css_js_1.groupBy)(allTokens, (x) => {
        const str = `/* Used by ${[...x.usedBy].sort().join(', ')} */`;
        return str;
    });
    const cssStrings = [...groupedByUsers.entries()]
        .map(([usedBy, x]) => {
        return (`    /* Used by ${[...x[0].usedBy].sort().join(', ')} */\n` +
            [...x]
                .map((x) => {
                const possibleValues = [...x.defaultValues].sort();
                let comment = '';
                comment += x.nameAnnotation
                    ? ` Named as ${JSON.stringify(x.nameAnnotation)} in Framer.`
                    : '';
                comment +=
                    possibleValues.length > 1
                        ? ` Also seen as ${possibleValues
                            .slice(1)
                            .join(', ')}.`
                        : '';
                return `    ${x.tokenName}: ${possibleValues[0]}; ${comment ? `/*${comment} */` : ''}`;
            })
                .join('\n'));
    })
        .join('\n');
    const tokensCss = `:root {\n${cssStrings}\n}`;
    return tokensCss;
}
const nodePath = process.argv[0] || 'node';
async function extractPropControlsUnsafe(filename, name) {
    const delimiter = '__delimiter__';
    let propCode = `JSON.stringify({propertyControls: x.default?.propertyControls, fonts: x?.default?.fonts } || {}, null, 2)`;
    const fileUrl = url_1.default.pathToFileURL(filename).href;
    const code = `import('${fileUrl}').then(x => { console.log('${delimiter}'); console.log(${propCode}) })`;
    const TIMEOUT = 5 * 1000;
    const UNFRAMER_MAP_PACKAGES = {
        unframer: url_1.default.pathToFileURL(require.resolve('../esm/index.js')).href,
        react: url_1.default.pathToFileURL(require.resolve('react')).href,
        'react-dom': url_1.default.pathToFileURL(require.resolve('react-dom')).href,
        'react/jsx-runtime': url_1.default.pathToFileURL(require.resolve('react/jsx-runtime')).href,
    };
    let loaderOption = `--loader "${url_1.default.pathToFileURL(require.resolve('../dist/unframer-loader.js'))}"`;
    try {
        require.resolve('unframer/package.json');
        UNFRAMER_MAP_PACKAGES.unframer = '';
    }
    catch { }
    let stdout = await new Promise((res, rej) => {
        const cmd = `"${nodePath}" --no-warnings --input-type=module ${loaderOption} -e "${code}"`;
        let childProcess = (0, child_process_1.exec)(cmd, {
            env: {
                // ...process.env,
                UNFRAMER_MAP_PACKAGES: JSON.stringify(UNFRAMER_MAP_PACKAGES),
            },
        }, (err, stdout, stderr) => {
            clearTimeout(timer);
            if (err) {
                utils_js_2.spinner.error(`error extracting types for ${name}`);
                console.error(stderr);
                return rej(err);
            }
            res(stdout);
        });
        const timer = setTimeout(() => {
            childProcess.kill();
            rej(new Error(`Timed out after ${TIMEOUT}ms while extracting types for ${name}`));
        }, TIMEOUT);
    }).catch((e) => {
        utils_js_2.logger.log(e.stack);
        return '';
    });
    stdout = stdout.split(delimiter)[1] || '';
    if (!stdout) {
        return {};
    }
    // console.log(stdout)
    return safeJsonParse(stdout);
}
function safeJsonParse(text) {
    try {
        return JSON.parse(text);
    }
    catch (e) {
        utils_js_2.logger.error('cannot parse json', text.slice(0, 100));
        return null;
    }
}
function propControlsToType({ config, fileName, controls, }) {
    try {
        const types = Object.entries(controls || {})
            .map(([key, value]) => {
            if (!value) {
                return;
            }
            const typescriptType = (value) => {
                value.type;
                switch (value.type) {
                    case framer_js_1.ControlType.Color:
                        return 'string';
                    case framer_js_1.ControlType.Boolean:
                        return 'boolean';
                    case framer_js_1.ControlType.Number:
                        return 'number';
                    case framer_js_1.ControlType.String:
                        return 'string';
                    case framer_js_1.ControlType.Enum: {
                        // @ts-expect-error
                        const options = value.optionTitles || value.options;
                        return options.map((x) => `'${x}'`).join(' | ');
                    }
                    case framer_js_1.ControlType.File:
                        return 'string';
                    case framer_js_1.ControlType.Image:
                        return 'string';
                    case framer_js_1.ControlType.ComponentInstance:
                        return 'React.ReactNode';
                    case framer_js_1.ControlType.Array:
                        // @ts-expect-error
                        return `${typescriptType(value.control)}[]`;
                    case framer_js_1.ControlType.Object:
                        // @ts-expect-error
                        return `{${Object.entries(value.controls)
                            .map(([k, v]) => {
                            // @ts-expect-error
                            return `${k}: ${typescriptType(v)}`;
                        })
                            .join(', ')}`;
                    case framer_js_1.ControlType.Date:
                        return 'string | Date';
                    case framer_js_1.ControlType.Link:
                        return 'string';
                    case framer_js_1.ControlType.ResponsiveImage:
                        return `{src: string, srcSet?: string, alt?: string}`;
                    case framer_js_1.ControlType.FusedNumber:
                        return 'number';
                    case framer_js_1.ControlType.Transition:
                        return 'any';
                    case framer_js_1.ControlType.EventHandler:
                        return 'Function';
                }
            };
            let name = (0, compat_js_1.propCamelCaseJustLikeFramer)(value.title || key || '');
            if (!name) {
                return '';
            }
            return `    ${JSON.stringify(name)}?: ${typescriptType(value)}`;
        })
            .filter(Boolean)
            .join('\n');
        const componentName = componentCamelCase(fileName);
        const defaultPropsTypes = [
            'children?: React.ReactNode',
            'locale?: Locale',
            'style?: React.CSSProperties',
            'className?: string',
            'id?: string',
            'width?: any',
            'height?: any',
            'layoutId?: string',
        ]
            .map((line) => `    ${line}`)
            .join('\n') + '\n';
        let t = '';
        t += '/* This file was generated by Unframer, do not edit manually */\n';
        t += 'import * as React from "react"\n\n';
        t += 'import { UnframerBreakpoint } from "unframer"\n\n';
        t += `type Locale = ${config.locales?.length
            ? config.locales.map((l) => `'${l.code}'`).join(' | ')
            : 'string'}\n`;
        t += `export interface Props {\n${defaultPropsTypes}${types}\n}\n\n`;
        t += `const ${componentName} = (props: Props) => any\n\n`;
        t += `type VariantsMap = Partial<Record<UnframerBreakpoint, Props['variant']>> & { base: Props['variant'] }\n\n`;
        t += `${componentName}.Responsive = (props: Omit<Props, 'variant'> & {variants?: VariantsMap}) => any\n\n`;
        t += `export default ${componentName}\n\n`;
        return t;
    }
    catch (e) {
        utils_js_2.logger.error('cannot generate types', e.stack);
        return '';
    }
}
function parsePropertyControls(code) {
    const start = code.indexOf('addPropertyControls(');
    if (start === -1) {
        utils_js_2.logger.error('no addPropertyControls call found');
        return null;
    }
    // count all parentheses to find when the addPropertyControls ends
    let openParentheses = 0;
    let closedParentheses = 0;
    let current = start;
    // parses using parentheses
    while (current < code.length) {
        const newP = code.indexOf('(', current);
        const newC = code.indexOf(')', current);
        if (newP === -1 && newC === -1) {
            break;
        }
        if (newP !== -1 && newP < newC) {
            openParentheses++;
            current = newP + 1;
        }
        if (newC !== -1 && newC < newP) {
            closedParentheses++;
            current = newC + 1;
        }
        if (openParentheses === closedParentheses) {
            break;
        }
    }
    const end = current;
    const propControls = code.substring(start, end);
    const realStart = propControls.indexOf(',');
    if (realStart === -1) {
        return '';
    }
    return propControls.slice(realStart + 1, -1);
}
function extractTokenInfo(code) {
    const lines = code.split('\n');
    const tokenLines = lines.filter((line) => line.includes('var(--token'));
    const tokens = [];
    for (const line of tokenLines) {
        let startIndex = 0;
        while (startIndex < line.length) {
            startIndex = line.indexOf('var(--', startIndex);
            if (startIndex === -1) {
                break;
            }
            let parCount = 0;
            let varStatement = '';
            for (let i = startIndex + 3; i < line.length; i++) {
                if (line[i] === '(') {
                    parCount++;
                }
                else if (line[i] === ')') {
                    parCount--;
                }
                varStatement += line[i];
                if (parCount === 0) {
                    break;
                }
            }
            varStatement = varStatement.trim().slice(1).slice(0, -1); // Remove starting and closing parenthesis
            const [tokenName, defaultValue] = splitOnce(varStatement, ',');
            let metadata;
            const jsonStartIndex = line.indexOf('/*', startIndex);
            if (jsonStartIndex !== -1) {
                const jsonEndIndex = line.indexOf('*/', jsonStartIndex);
                if (jsonEndIndex !== -1) {
                    const jsonString = line
                        .slice(jsonStartIndex + 2, jsonEndIndex)
                        .trim();
                    try {
                        metadata = JSON.parse(jsonString);
                    }
                    catch (error) {
                        // console.warn('Failed to parse JSON metadata:', error)
                    }
                }
            }
            if (tokenName && defaultValue) {
                tokens.push({
                    tokenName,
                    defaultValue: defaultValue.trim(),
                    metadata,
                });
            }
            startIndex += varStatement.length + 'var(--'.length; // Move the startIndex to the end of the current var(--token)
        }
    }
    return tokens;
}
function splitOnce(str, separator) {
    const index = str.indexOf(separator);
    if (index === -1) {
        return [str];
    }
    return [str.slice(0, index), str.slice(index + 1)];
}
function componentCamelCase(str) {
    str = str?.replace(/\.jsx?$/, '');
    if (!str) {
        return 'FramerComponent';
    }
    // Take last part after slashes
    str = str.split('/').filter(Boolean).pop() || '';
    str = str.replace(/-([\w])/g, (g) => g[1].toUpperCase());
    str = str.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
    str = str[0].toUpperCase() + str.slice(1);
    str = str + 'FramerComponent';
    return str;
}
const breakpointVariants = ['mobile', 'tablet', 'desktop'];
function getVariantsFromPropControls(propControls) {
    if (!propControls?.variant) {
        return null;
    }
    let variants = propControls.variant?.['optionTitles'] ||
        propControls.variant?.['options'] ||
        [];
    // Sort breakpoint-related variants first
    return {
        variants: variants,
        breakpoints: variants.filter((v) => breakpointVariants.some((device) => v.toLowerCase().includes(device))),
    };
}
function findExampleProperty(propertyControls) {
    if (!propertyControls) {
        return null;
    }
    const stringProp = Object.entries(propertyControls).find(([_, control]) => {
        // console.log('control', _, control)
        return control?.type === framer_js_1.ControlType.String;
    });
    if (!stringProp) {
        return null;
    }
    return (0, compat_js_1.propCamelCaseJustLikeFramer)(stringProp[1]?.title || '');
}
// these styles are global styles injected by Framer in the generated websites, without them things like icons can look weird
const resetCssStyles = `

:root {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

* {
    box-sizing: border-box;
    -webkit-font-smoothing: inherit;
}

.unframer h1, .unframer h2, .unframer h3, .unframer h4, .unframer h5, .unframer h6, .unframer p, .unframer figure {
    margin: 0;
}

.unframer {
    line-height: normal;
}

.unframer, .unframer input, .unframer textarea, .unframer select, .unframer button {
    font-size: 12px;
    font-family: sans-serif;
}
`;
async function recursiveReaddir(dir) {
    const dirents = await fs_1.default.promises.readdir(dir, { withFileTypes: true });
    const files = await Promise.all(dirents.map((dirent) => {
        const res = path_1.default.resolve(dir, dirent.name);
        return dirent.isDirectory() ? recursiveReaddir(res) : res;
    }));
    return files.flat();
}
function indentWithTabs(str, tabs) {
    if (!str)
        return '';
    return str
        .split('\n')
        .map((line, i) => (!i ? line : tabs + line))
        .join('\n');
}
async function createExampleComponentCode({ outDir, config, }) {
    const outDirForExample = path_1.default.posix
        .relative(process.cwd(), outDir)
        .replace(/^src\//, ''); // remove src so file works inside src
    const instances = config?.componentInstancesInIndexPage?.sort((a, b) => {
        // Order first by nodeDepth (lower is better)
        return a.nodeDepth - b.nodeDepth || a.pageOrdering - b.pageOrdering;
    });
    const imports = instances?.map((exampleComponent) => {
        return `import ${componentCamelCase(exampleComponent?.componentPathSlug)} from './${outDirForExample}/${exampleComponent?.componentPathSlug}'`;
    });
    const jsx = instances?.map((exampleComponent) => {
        let propStr = '';
        for (let [key, value] of Object.entries(exampleComponent.controls || {})) {
            if (key === 'variant') {
                continue;
            }
            if (typeof value === 'object') {
                continue;
            }
            // TODO get property controls to render enums much better? maybe do this in plugin instead
            propStr += '\n';
            propStr += `  ${key}={${JSON.stringify(value)}}`;
        }
        if (propStr)
            propStr += '\n';
        const responsiveComponent = `<${componentCamelCase(exampleComponent?.componentPathSlug)}.Responsive${propStr}/>`;
        return responsiveComponent;
    });
    let containerClasses = '';
    if (config.pageBackgroundColor) {
        let bg = config.pageBackgroundColor?.replace(' ', '_');
        containerClasses += `bg-[${bg}]`;
    }
    const exampleCode = (0, utils_js_1.dedent) `
      import './${outDirForExample}/styles.css'

      ${indentWithTabs(imports?.join('\n'), '')}

      export default function App() {
        return (
          <div className='flex flex-col items-center gap-3 ${containerClasses}'>
            ${indentWithTabs(jsx?.join('\n'), '      ')}
          </div>
        );
      };
      `;
    return {
        exampleCode,
    };
}
//# sourceMappingURL=exporter.js.map