import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { CallToolRequestSchema, ListResourcesRequestSchema, ListToolsRequestSchema, ReadResourceRequestSchema, } from '@modelcontextprotocol/sdk/types.js';
import { SSEServerTransportSpiceflow } from "./mcp-transport.js";
import { openapi } from "./openapi.js";
import { Spiceflow } from "./spiceflow.js";
const transports = new Map();
function getOperationRequestBody(operation) {
    if (!operation.requestBody)
        return undefined;
    const requestBody = operation.requestBody;
    const content = requestBody.content['application/json'];
    return content?.schema;
}
function getOperationParameters(operation) {
    if (!operation.parameters)
        return {};
    const queryProperties = {};
    const pathProperties = {};
    const queryRequired = [];
    const pathRequired = [];
    operation.parameters.forEach((param) => {
        if ('$ref' in param)
            return; // TODO referenced parameters
        if (param.in === 'query') {
            queryProperties[param.name] = param.schema;
            if (param.required)
                queryRequired.push(param.name);
        }
        else if (param.in === 'path') {
            pathProperties[param.name] = param.schema;
            if (param.required)
                pathRequired.push(param.name);
        }
    });
    const result = {};
    if (Object.keys(queryProperties).length > 0) {
        result.queryParams = {
            type: 'object',
            properties: queryProperties,
            required: queryRequired.length > 0 ? queryRequired : undefined,
        };
    }
    if (Object.keys(pathProperties).length > 0) {
        result.pathParams = {
            type: 'object',
            properties: pathProperties,
            required: pathRequired.length > 0 ? pathRequired : undefined,
        };
    }
    return result;
}
function createMCPServer({ name = 'spiceflow', version = '1.0.0', openapi, app, }) {
    const server = new Server({ name, version }, {
        capabilities: {
            tools: {},
            resources: {},
        },
    });
    const basePath = app.topLevelApp.prefix || '';
    server.setRequestHandler(ListToolsRequestSchema, async () => {
        const paths = Object.entries(openapi.paths).filter(([path]) => !['/mcp-openapi', '/mcp', '/mcp/message'].includes(path.replace(basePath, '')));
        const tools = paths.flatMap(([path, pathObj]) => Object.entries(pathObj || {})
            .filter(([method]) => method !== 'parameters')
            .map(([method, operation]) => {
            const properties = {};
            const required = [];
            const requestBody = getOperationRequestBody(operation);
            if (requestBody) {
                properties.body = requestBody;
                required.push('body');
            }
            const { queryParams, pathParams } = getOperationParameters(operation);
            if (queryParams) {
                properties.query = queryParams;
            }
            if (pathParams) {
                properties.params = pathParams;
            }
            return {
                name: getRouteName({ method, path }),
                description: operation.description ||
                    operation.summary ||
                    `${method.toUpperCase()} ${path}`,
                inputSchema: {
                    type: 'object',
                    properties,
                    required: required.length > 0 ? required : undefined,
                },
            };
        }));
        return { tools };
    });
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
        const toolName = request.params.name;
        let { path, method } = getPathFromToolName(toolName);
        const pathObj = openapi.paths[path];
        if (!pathObj || !pathObj[method.toLowerCase()]) {
            return {
                content: [{ type: 'text', text: `Tool ${toolName} not found` }],
                isError: true,
            };
        }
        try {
            const { body, query, params } = request.params.arguments || {};
            if (params) {
                Object.entries(params).forEach(([key, value]) => {
                    path = path.replace(`{${key}}`, encodeURIComponent(String(value)));
                });
            }
            const basePath = app.topLevelApp.prefix || '';
            const url = new URL(`http://localhost${basePath}${path}`);
            if (query) {
                Object.entries(query).forEach(([key, value]) => {
                    url.searchParams.set(key, String(value));
                });
            }
            const response = await app.handle(new Request(url, {
                method: method,
                headers: {
                    'content-type': 'application/json',
                },
                body: body ? JSON.stringify(body) : undefined,
            }));
            const isError = !response.ok;
            const contentType = response.headers.get('content-type');
            if (contentType?.includes('application/json')) {
                const json = await response.json();
                return {
                    isError,
                    content: [{ type: 'text', text: JSON.stringify(json, null, 2) }],
                };
            }
            const text = await response.text();
            return {
                isError,
                content: [{ type: 'text', text }],
            };
        }
        catch (error) {
            return {
                content: [{ type: 'text', text: error.message || 'Unknown error' }],
                isError: true,
            };
        }
    });
    server.setRequestHandler(ListResourcesRequestSchema, async () => {
        const resources = [];
        for (const [path, pathObj] of Object.entries(openapi.paths)) {
            if (path.startsWith('/mcp')) {
                continue;
            }
            const getOperation = pathObj?.get;
            if (getOperation && !path.includes('{')) {
                const { queryParams } = getOperationParameters(getOperation);
                const hasRequiredQuery = queryParams?.required && queryParams.required.length > 0;
                if (!hasRequiredQuery) {
                    resources.push({
                        uri: new URL(path, 'http://localhost').href,
                        mimeType: 'application/json',
                        name: `GET ${path}`,
                    });
                }
            }
        }
        return { resources };
    });
    server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
        const resourceUrl = new URL(request.params.uri);
        const path = resourceUrl.pathname;
        const pathObj = openapi.paths[path];
        if (!pathObj?.get) {
            throw new Error('Resource not found');
        }
        const response = await app.handle(new Request(resourceUrl, {
            method: 'GET',
            headers: {
                'content-type': 'application/json',
            },
        }));
        const contentType = response.headers.get('content-type');
        const text = await response.text();
        if (contentType?.includes('application/json')) {
            return {
                contents: [
                    {
                        uri: request.params.uri,
                        mimeType: 'application/json',
                        text: text,
                    },
                ],
            };
        }
        return {
            contents: [
                {
                    uri: request.params.uri,
                    mimeType: 'text/plain',
                    text,
                },
            ],
        };
    });
    return { server, transports };
}
export const mcp = ({ path = '/mcp', name = 'spiceflow', version = '1.0.0', } = {}) => {
    const messagePath = path + '/message';
    let app = new Spiceflow({ name: 'mcp' })
        .use(openapi({ path: '/mcp-openapi' }))
        .post(messagePath, async ({ request, query }) => {
        const sessionId = query.sessionId;
        const t = transports.get(sessionId);
        if (!t) {
            return new Response('Session not found', { status: 404 });
        }
        await t.handlePostMessage(request);
        return 'ok';
    })
        .get(path, async ({ request }) => {
        const basePath = app.topLevelApp.prefix || '';
        const transport = new SSEServerTransportSpiceflow(basePath + messagePath);
        transports.set(transport.sessionId, transport);
        const openapi = await app
            .topLevelApp.handle(new Request(`http://localhost${basePath}/mcp-openapi`))
            .then((r) => r.json());
        const { server } = createMCPServer({
            name,
            version,
            openapi,
            app: app.topLevelApp,
        });
        server.onclose = () => {
            transports.delete(transport.sessionId);
        };
        await server.connect(transport);
        request.signal.addEventListener('abort', () => {
            transport.close().catch((error) => {
                console.error('Error closing transport:', error);
            });
        });
        if (request.method === 'POST') {
            return await transport.handlePostMessage(request);
        }
        return transport.response;
    });
    return app;
};
function getRouteName({ method, path, }) {
    return `${method.toUpperCase()} ${path}`;
}
function getPathFromToolName(toolName) {
    const parts = toolName.split(' ');
    if (parts.length < 2) {
        throw new Error('Invalid tool name format');
    }
    const method = parts[0].toUpperCase();
    const path = parts.slice(1).join(' ');
    return { path, method };
}
