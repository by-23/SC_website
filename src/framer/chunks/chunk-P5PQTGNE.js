// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 61763921e49c2823 "Suprema (copy)", do not edit manually */
// /:https://framerusercontent.com/modules/xFhv3ETdRBLjJusGaZ1P/d9ZONLqTB9uCj5kbWKll/Globe.js
import { jsx as _jsx } from "react/jsx-runtime";
import { addPropertyControls, ControlType, Color, RenderTarget } from "unframer";
import { useEffect, useRef } from "react";

// /:https://esm.sh/*phenomenon@1.6.0/es2022/phenomenon.mjs
var m = ["x", "y", "z"];
var l = function(t) {
  Object.assign(this, { uniforms: {}, geometry: { vertices: [{ x: 0, y: 0, z: 0 }] }, mode: 0, modifiers: {}, attributes: [], multiplier: 1, buffers: [] }), Object.assign(this, t), this.prepareProgram(), this.prepareUniforms(), this.prepareAttributes();
};
l.prototype.compileShader = function(t, e) {
  var i = this.gl.createShader(t);
  return this.gl.shaderSource(i, e), this.gl.compileShader(i), i;
}, l.prototype.prepareProgram = function() {
  var t = this.gl, e = this.vertex, i = this.fragment, s = t.createProgram();
  t.attachShader(s, this.compileShader(35633, e)), t.attachShader(s, this.compileShader(35632, i)), t.linkProgram(s), t.useProgram(s), this.program = s;
}, l.prototype.prepareUniforms = function() {
  for (var t = Object.keys(this.uniforms), e = 0; e < t.length; e += 1) {
    var i = this.gl.getUniformLocation(this.program, t[e]);
    this.uniforms[t[e]].location = i;
  }
}, l.prototype.prepareAttributes = function() {
  this.geometry.vertices !== void 0 && this.attributes.push({ name: "aPosition", size: 3 }), this.geometry.normal !== void 0 && this.attributes.push({ name: "aNormal", size: 3 }), this.attributeKeys = [];
  for (var t = 0; t < this.attributes.length; t += 1) this.attributeKeys.push(this.attributes[t].name), this.prepareAttribute(this.attributes[t]);
}, l.prototype.prepareAttribute = function(t) {
  for (var e = this.geometry, i = this.multiplier, s = e.vertices, o = e.normal, h2 = new Float32Array(i * s.length * t.size), u2 = 0; u2 < i; u2 += 1) for (var r = t.data && t.data(u2, i), a = u2 * s.length * t.size, n2 = 0; n2 < s.length; n2 += 1) for (var f = 0; f < t.size; f += 1) {
    var p2 = this.modifiers[t.name];
    h2[a] = p2 !== void 0 ? p2(r, n2, f, this) : t.name === "aPosition" ? s[n2][m[f]] : t.name === "aNormal" ? o[n2][m[f]] : r[f], a += 1;
  }
  this.attributes[this.attributeKeys.indexOf(t.name)].data = h2, this.prepareBuffer(this.attributes[this.attributeKeys.indexOf(t.name)]);
}, l.prototype.prepareBuffer = function(t) {
  var e = t.data, i = t.name, s = t.size, o = this.gl.createBuffer();
  this.gl.bindBuffer(34962, o), this.gl.bufferData(34962, e, 35044);
  var h2 = this.gl.getAttribLocation(this.program, i);
  this.gl.enableVertexAttribArray(h2), this.gl.vertexAttribPointer(h2, s, 5126, false, 0, 0), this.buffers[this.attributeKeys.indexOf(t.name)] = { buffer: o, location: h2, size: s };
}, l.prototype.render = function(t) {
  var e = this, i = this.uniforms, s = this.multiplier, o = this.gl;
  o.useProgram(this.program);
  for (var h2 = 0; h2 < this.buffers.length; h2 += 1) {
    var u2 = this.buffers[h2], r = u2.location, a = u2.buffer, n2 = u2.size;
    o.enableVertexAttribArray(r), o.bindBuffer(34962, a), o.vertexAttribPointer(r, n2, 5126, false, 0, 0);
  }
  Object.keys(t).forEach(function(f) {
    i[f].value = t[f].value;
  }), Object.keys(i).forEach(function(f) {
    var p2 = i[f];
    e.uniformMap[p2.type](p2.location, p2.value);
  }), o.drawArrays(this.mode, 0, s * this.geometry.vertices.length), this.onRender && this.onRender(this);
}, l.prototype.destroy = function() {
  for (var t = 0; t < this.buffers.length; t += 1) this.gl.deleteBuffer(this.buffers[t].buffer);
  this.gl.deleteProgram(this.program), this.gl = null;
};
var c = function(t) {
  var e = this, i = t || {}, s = i.canvas;
  s === void 0 && (s = document.querySelector("canvas"));
  var o = i.context;
  o === void 0 && (o = {});
  var h2 = i.contextType;
  h2 === void 0 && (h2 = "experimental-webgl");
  var u2 = i.settings;
  u2 === void 0 && (u2 = {});
  var r = s.getContext(h2, Object.assign({ alpha: false, antialias: false }, o));
  Object.assign(this, { gl: r, canvas: s, uniforms: {}, instances: /* @__PURE__ */ new Map(), shouldRender: true }), Object.assign(this, { devicePixelRatio: 1, clearColor: [1, 1, 1, 1], position: { x: 0, y: 0, z: 2 }, clip: [1e-3, 100] }), Object.assign(this, u2), this.uniformMap = { float: function(a, n2) {
    return r.uniform1f(a, n2);
  }, vec2: function(a, n2) {
    return r.uniform2fv(a, n2);
  }, vec3: function(a, n2) {
    return r.uniform3fv(a, n2);
  }, vec4: function(a, n2) {
    return r.uniform4fv(a, n2);
  }, mat2: function(a, n2) {
    return r.uniformMatrix2fv(a, false, n2);
  }, mat3: function(a, n2) {
    return r.uniformMatrix3fv(a, false, n2);
  }, mat4: function(a, n2) {
    return r.uniformMatrix4fv(a, false, n2);
  } }, r.enable(r.DEPTH_TEST), r.depthFunc(r.LEQUAL), r.getContextAttributes().alpha === false && (r.clearColor.apply(r, this.clearColor), r.clearDepth(1)), this.onSetup && this.onSetup(r), window.addEventListener("resize", function() {
    return e.resize();
  }), this.resize(), this.render();
};
c.prototype.resize = function() {
  var t = this.gl, e = this.canvas, i = this.devicePixelRatio, s = this.position;
  e.width = e.clientWidth * i, e.height = e.clientHeight * i;
  var o = t.drawingBufferWidth, h2 = t.drawingBufferHeight, u2 = o / h2;
  t.viewport(0, 0, o, h2);
  var r = Math.tan(Math.PI / 180 * 22.5), a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, s.x, s.y, (u2 < 1 ? 1 : u2) * -s.z, 1];
  this.uniforms.uProjectionMatrix = { type: "mat4", value: [0.5 / r, 0, 0, 0, 0, u2 / r * 0.5, 0, 0, 0, 0, -(this.clip[1] + this.clip[0]) / (this.clip[1] - this.clip[0]), -1, 0, 0, -2 * this.clip[1] * (this.clip[0] / (this.clip[1] - this.clip[0])), 0] }, this.uniforms.uViewMatrix = { type: "mat4", value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] }, this.uniforms.uModelMatrix = { type: "mat4", value: a };
}, c.prototype.toggle = function(t) {
  t !== this.shouldRender && (this.shouldRender = t !== void 0 ? t : !this.shouldRender, this.shouldRender && this.render());
}, c.prototype.render = function() {
  var t = this;
  this.gl.clear(16640), this.instances.forEach(function(e) {
    e.render(t.uniforms);
  }), this.onRender && this.onRender(this), this.shouldRender && requestAnimationFrame(function() {
    return t.render();
  });
}, c.prototype.add = function(t, e) {
  e === void 0 && (e = { uniforms: {} }), e.uniforms === void 0 && (e.uniforms = {}), Object.assign(e.uniforms, JSON.parse(JSON.stringify(this.uniforms))), Object.assign(e, { gl: this.gl, uniformMap: this.uniformMap });
  var i = new l(e);
  return this.instances.set(t, i), i;
}, c.prototype.remove = function(t) {
  var e = this.instances.get(t);
  e !== void 0 && (e.destroy(), this.instances.delete(t));
}, c.prototype.destroy = function() {
  var t = this;
  this.instances.forEach(function(e, i) {
    e.destroy(), t.instances.delete(i);
  }), this.toggle(false);
};
var d = c;

// /:https://esm.sh/*cobe@0.6.4/es2022/cobe.mjs
var p = "phi";
var y = "theta";
var h = "mapSamples";
var b = "mapBrightness";
var w = "baseColor";
var E = "markerColor";
var C = "glowColor";
var n = "markers";
var z = "diffuse";
var v = "devicePixelRatio";
var M = "dark";
var B = "offset";
var D = "scale";
var R = "opacity";
var Q = "mapBaseBrightness";
var d2 = { [p]: "A", [y]: "B", [h]: "m", [b]: "E", [w]: "R", [E]: "S", [C]: "z", [z]: "F", [M]: "G", [B]: "y", [D]: "C", [R]: "H", [Q]: "I" };
var { PI: g, sin: m2, cos: x } = Math;
var u = (l2) => [].concat(...l2.map((o) => {
  let [t, r] = o.location;
  t = t * g / 180, r = r * g / 180 - g;
  let c2 = x(t), e = [-c2 * x(r), m2(t), c2 * m2(r), o.size], a = o.color ? [...o.color, 1] : [0, 0, 0, 0];
  return [...e, ...a];
}), [0, 0, 0, 0, 0, 0, 0, 0]);
var k = (l2, o) => {
  let t = (e, a, i) => ({ type: e, value: typeof o[a] > "u" ? i : o[a] }), r = l2.getContext("webgl2") ? "webgl2" : l2.getContext("webgl") ? "webgl" : "experimental-webgl", c2 = new d({ canvas: l2, contextType: r, context: { alpha: true, stencil: false, antialias: true, depth: false, preserveDrawingBuffer: false, ...o.context }, settings: { [v]: o[v] || 1, onSetup: (e) => {
    let a = e.RGB, i = e.UNSIGNED_BYTE, f = e.TEXTURE_2D, s = e.createTexture();
    e.bindTexture(f, s), e.texImage2D(f, 0, a, 1, 1, 0, a, i, new Uint8Array([0, 0, 0, 0]));
    let A = new Image();
    A.onload = () => {
      e.bindTexture(f, s), e.texImage2D(f, 0, a, a, i, A), e.generateMipmap(f);
      let F = e.getParameter(e.CURRENT_PROGRAM), S = e.getUniformLocation(F, "J");
      e.texParameteri(f, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(f, e.TEXTURE_MAG_FILTER, e.NEAREST), e.uniform1i(S, 0);
    }, A.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACAAQAAAADMzoqnAAAAAXNSR0IArs4c6QAABA5JREFUeNrV179uHEUAx/Hf3JpbF+E2VASBsmVKTBcpKJs3SMEDcDwBiVJAAewYEBUivIHT0uUBIt0YCovKD0CRjUC4QfHYh8hYXu+P25vZ2Zm9c66gMd/GJ/tz82d3bk8GN4SrByYF2366FNTACIAkivVAAazQdnf3MvAlbNUQfOPAdQDvSAimMWhwy4I2g4SU+Kp04ISLpPBAKLxPyic3O/CCi+Y7rUJbiodcpDOFY7CgxCEXmdYD2EYK2s5lApOx5pEDDYCUwM1XdJUwBV11QQMg59kePSCaPAASQMEL2hwo6TJFgxpg+TgC2ymXPbuvc40awr3D1QCFfbH9kcoqAOkZozpQo0aqAGQRKCog/+tjkgbNFEtg2FffBvBGlSxHoAaAa1u6X4PBAwDiR8FFsrQgeUhfJTSALaB9jy5NCybJPn1SVFiWk7ywN+KzhH1aKAuydhGkbEF4lWohLXDXavlyFgHY7LBnLRdlAP6BS5Cc8RfVDXbkwN/oIvmY+6obbNeBP0JwTuMGu9gTzy1Q4RS/cWpfzszeYwd+CAFrtBW/Hur0gLbJGlD+/OjVwe/drfBxkbbg63dndEDfiEBlAd7ac0BPe1D6Jd8dfbLH+RI0OzseFB5s01/M+gMdAeluLOCAuaUA9Lezo/vSgXoCX9rtEiXnp7Q1W/CNyWcd8DXoS6jH/YZ5vAJEWY2dXFQe2TUgaFaNejCzJ98g6HnlVrsE58sDcYqg+9XY75fPqdoh/kRQWiXKg8MWlJQxUFMPjqnyujhFBE7UxIMjyszk0QwQlFsezImsyvUYYYVED2pk6m0Tg8T04Fwjk2kdAwSACqlM6gRRt3vQYAFGX0Ah7Ebx1H+MDRI5ui0QldH4j7FGcm90XdxD2Jg1AOEAVAKhEFXSn4cKUELurIAKwJ3MArypPscQaLhJFICJ0ohjDySAdH8AhDtCiTuMycH8CXzhH9jUACAO5uMhoAwA5i+T6WAKmmAqnLy80wxHqIPFYpqCwxGaYLt4Dyievg5kEoVEUAhs6pqKgFtDQYOuaXypaWKQfIuwwoGSZgfLsu/XAtI8cGN+h7Cc1A5oLOMhwlIPXuhu48AIvsSBkvtV9wsJRKCyYLfq5lTrQMFd1a262oqBck9K1V0YjQg0iEYYgpS1A9GlXQV5cykwm4A7BzVsxQqo7E+zCegO7Ma7yKgsuOcfKbMBwLC8wvVNYDsANYalEpOAa6zpWjTeMKGwEwC1CiQewJc5EKfgy7GmRAZA4vUVGwE2dPM/g0xuAInE/yG5aZ8ISxWGfYigUVbdyBElTHh2uCwGdfCkOLGgQVBh3Ewp+/QK4CDlR5Ws/Zf7yhCf8pH7vinWAvoVCQ6zz0NX5V/6GkAVV+2/5qsJ/gU8bsxpM8IeAQAAAABJRU5ErkJggg==";
  } } });
  return c2.add("", { vertex: "attribute vec3 aPosition;uniform mat4 uProjectionMatrix;uniform mat4 uModelMatrix;uniform mat4 uViewMatrix;void main(){gl_Position=uProjectionMatrix*uModelMatrix*uViewMatrix*vec4(aPosition,1.);}", fragment: "precision highp float;uniform vec2 t,y;uniform vec3 R,S,z;uniform vec4 v[64*2];uniform float A,B,m,C,D,E,F,G,H,I;uniform sampler2D J;float K=1./m;mat3 L(float a,float b){float c=cos(a),d=cos(b),e=sin(a),f=sin(b);return mat3(d,f*e,-f*c,0.,c,e,f,d*-e,d*c);}vec3 w(vec3 c,out float x){c=c.xzy;float p=max(2.,floor(log2(2.236068*m*3.141593*(1.-c.z*c.z))*.72021));vec2 g=floor(pow(1.618034,p)/2.236068*vec2(1.,1.618034)+.5),d=fract((g+1.)*.618034)*6.283185-3.883222,e=-2.*g,f=vec2(atan(c.y,c.x),c.z-1.),q=floor(vec2(e.y*f.x-d.y*(f.y*m+1.),-e.x*f.x+d.x*(f.y*m+1.))/(d.x*e.y-e.x*d.y));float n=3.141593;vec3 r;for(float h=0.;h<4.;h+=1.){vec2 s=vec2(mod(h,2.),floor(h*.5));float j=dot(g,q+s);if(j>m)continue;float a=j,b=0.;if(a>=524288.)a-=524288.,b+=.803894;if(a>=262144.)a-=262144.,b+=.901947;if(a>=131072.)a-=131072.,b+=.950973;if(a>=65536.)a-=65536.,b+=.475487;if(a>=32768.)a-=32768.,b+=.737743;if(a>=16384.)a-=16384.,b+=.868872;if(a>=8192.)a-=8192.,b+=.934436;if(a>=4096.)a-=4096.,b+=.467218;if(a>=2048.)a-=2048.,b+=.733609;if(a>=1024.)a-=1024.,b+=.866804;if(a>=512.)a-=512.,b+=.433402;if(a>=256.)a-=256.,b+=.216701;if(a>=128.)a-=128.,b+=.108351;if(a>=64.)a-=64.,b+=.554175;if(a>=32.)a-=32.,b+=.777088;if(a>=16.)a-=16.,b+=.888544;if(a>=8.)a-=8.,b+=.944272;if(a>=4.)a-=4.,b+=.472136;if(a>=2.)a-=2.,b+=.236068;if(a>=1.)a-=1.,b+=.618034;float k=fract(b)*6.283185,i=1.-2.*j*K,l=sqrt(1.-i*i);vec3 o=vec3(cos(k)*l,sin(k)*l,i);float u=length(c-o);if(u<n)n=u,r=o;}x=n;return r.xzy;}void main(){vec2 b=(gl_FragCoord.xy/t*2.-1.)/C-y*vec2(1.,-1.)/t;b.x*=t.x/t.y;float c=dot(b,b);vec4 x=vec4(0.);float n=0.;if(c<=.64){for(int g=0;g<2;g++){vec4 e=vec4(0.);float a;vec3 u=vec3(0.,0.,1.),h=normalize(vec3(b,sqrt(.64-c)));h.z*=g>0?-1.:1.,u.z*=g>0?-1.:1.;vec3 i=h*L(B,A),j=w(i,a);float o=asin(j.y),k=acos(-j.x/cos(o));k=j.z<0.?-k:k;float M=max(texture2D(J,vec2(k*.5/3.141593,-(o/3.141593+.5))).x,I),N=smoothstep(8e-3,0.,a),l=dot(h,u),p=pow(l,F)*E,q=M*N*p,T=mix((1.-q)*pow(l,.4),q,G)+.1;e+=vec4(R*T,1.);int U=int(D);float V=0.;for(int d=0;d<64;d++){if(d>=U)break;vec4 r=v[d*2],O=v[d*2+1];vec3 s=r.xyz,P=s-i;float f=r.w;if(dot(P,P)>f*f*4.)continue;vec3 W=w(s,a);a=length(W-i);if(a<f)V+=smoothstep(f*.5,0.,a),e.xyz=O.w>.5?mix(e.xyz,O.xyz,smoothstep(f*.5,0.,a)*p):mix(e.xyz,S,smoothstep(f*.5,0.,a)*p);}e.xyz+=pow(1.-l,4.)*z,x+=e*(1.+(g>0?-H:H))/2.;}n=pow(dot(normalize(vec3(-b,sqrt(1.-c))),vec3(0.,0.,1.)),4.)*smoothstep(0.,1.,.2/(c-.64));}else{float Q=sqrt(.2/(c-.64));n=smoothstep(.5,1.,Q/(Q+1.));}gl_FragColor=x+vec4(n*z,n);}", uniforms: { t: { type: "vec2", value: [o.width, o.height] }, A: t("float", p), B: t("float", y), m: t("float", h), E: t("float", b), I: t("float", Q), R: t("vec3", w), S: t("vec3", E), F: t("float", z), z: t("vec3", C), G: t("float", M), v: { type: "vec4", value: u(o[n]) }, D: { type: "float", value: o[n].length }, y: t("vec2", B, [0, 0]), C: t("float", D, 1), H: t("float", R, 1) }, mode: 4, geometry: { vertices: [{ x: -100, y: 100, z: 0 }, { x: -100, y: -100, z: 0 }, { x: 100, y: 100, z: 0 }, { x: 100, y: -100, z: 0 }, { x: -100, y: -100, z: 0 }, { x: 100, y: 100, z: 0 }] }, onRender: ({ uniforms: e }) => {
    let a = {};
    if (o.onRender) {
      a = o.onRender(a) || a;
      for (let i in d2) a[i] !== void 0 && (e[d2[i]].value = a[i]);
      a[n] !== void 0 && (e.v.value = u(a[n]), e.D.value = a[n].length), a.width && a.height && (e.t.value = [a.width, a.height]);
    }
  } }), c2;
};

// /:https://framerusercontent.com/modules/xFhv3ETdRBLjJusGaZ1P/d9ZONLqTB9uCj5kbWKll/Globe.js
import { useSpring } from "unframer";
function Globe(props) {
  const { background, baseColor, glowColor, isDraggable, dragOptions, speed, theta, phi, dark, diffuse, maxSamples, mapBrightness, markerSize, markerArray, markerColor, scale, alignment, maxWidth, offset } = props;
  const { offsetX, offsetY } = offset;
  const { stiffness, damping, mass } = dragOptions;
  const canvasRef = useRef();
  const pointerInteracting = useRef(null);
  const pointerInteractionMovement = useRef(0);
  const isCanvas = RenderTarget.current() === RenderTarget.canvas;
  const r = useSpring(0, { stiffness, damping, mass, restDelta: 1e-4, restSpeed: 1e-4 });
  const fadeMask = "radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 70%)";
  useEffect(() => {
    let phiValue = phi;
    let width = 0;
    const onResize = () => {
      if (canvasRef.current && (width = canvasRef.current.offsetWidth)) {
        window.addEventListener("resize", onResize);
      }
    };
    onResize();
    const baseConvert = convertRGB(baseColor);
    const glowConvert = convertRGB(glowColor);
    const markerConvert = convertRGB(markerColor);
    const globe = k(canvasRef.current, { devicePixelRatio: 2, width: width * 2, height: width * 2, phi, theta, dark, diffuse, mapSamples: maxSamples, mapBrightness, baseColor: [baseConvert.r, baseConvert.g, baseConvert.b], glowColor: [glowConvert.r, glowConvert.g, glowConvert.b], markerColor: [markerConvert.r, markerConvert.g, markerConvert.b], markers: markerArray.map((marker) => {
      return { location: [marker.latitude, marker.longitude], size: markerSize };
    }), scale, offset: [offsetX, offsetY], onRender: (state) => {
      if (!isCanvas) {
        state.phi = phiValue + r.get();
      }
      state.width = width * 2;
      state.height = width * 2;
      if (!isCanvas) {
        state.phi = phiValue + r.get();
        phiValue += speed / 200;
      }
    } });
    return () => {
      globe.destroy();
    };
  }, [props]);
  return /* @__PURE__ */ _jsx("div", { style: { ...flexStyles, placeItems: alignment, background }, children: /* @__PURE__ */ _jsx("div", { style: { width: "100%", aspectRatio: "1/1", maxWidth, WebkitMaskImage: fadeMask, MozMaskImage: fadeMask, maskImage: fadeMask }, children: /* @__PURE__ */ _jsx("canvas", { ref: canvasRef, style: { width: "100%", height: "100%", contain: "layout paint size", cursor: "auto", userSelect: "none" }, onPointerDown: (e) => {
    if (isDraggable) {
      pointerInteracting.current = e.clientX - pointerInteractionMovement.current;
      canvasRef.current.style.cursor = "grabbing";
    }
  }, onPointerUp: () => {
    if (isDraggable) {
      pointerInteracting.current = null;
      canvasRef.current.style.cursor = "grab";
    }
  }, onPointerOver: () => {
    if (isDraggable) {
      canvasRef.current.style.cursor = "grab";
    }
  }, onPointerOut: () => {
    if (isDraggable) {
      pointerInteracting.current = null;
      canvasRef.current.style.cursor = "auto";
    }
  }, onMouseMove: (e) => {
    if (isDraggable) {
      if (pointerInteracting.current !== null) {
        const delta = e.clientX - pointerInteracting.current;
        pointerInteractionMovement.current = delta;
        r.set(delta / 100);
      }
    }
  }, onTouchMove: (e) => {
    if (pointerInteracting.current !== null && e.touches[0]) {
      const delta = e.touches[0].clientX - pointerInteracting.current;
      pointerInteractionMovement.current = delta;
      r.set(delta / 100);
    }
  } }) }) });
}
Globe.defaultProps = { background: "#000000", baseColor: "#333333", glowColor: "#ffffff", markerColor: "#ffffff", isDraggable: true, dragOptions: { stiffness: 200, damping: 40, mass: 1 }, speed: 1, phi: 0, theta: 0.3, dark: 1, diffuse: 2, mapBrightness: 20, maxSamples: 2e4, markerSize: 0.1, markerArray: { latitude: 52.3676, longitude: 4.9041 }, scale: 1, alignment: "center", maxWidth: 800, offset: { offsetX: 0, offsetY: 0 } };
Globe.displayName = "Globe";
var dp = Globe.defaultProps;
var dpOffset = Globe.defaultProps.offset;
var dpDrag = Globe.defaultProps.dragOptions;
addPropertyControls(Globe, { background: { type: ControlType.Color, title: "Backdrop", defaultValue: dp.background }, baseColor: { type: ControlType.Color, title: "Base", defaultValue: dp.baseColor }, glowColor: { type: ControlType.Color, title: "Glow", defaultValue: dp.glowColor }, markerColor: { type: ControlType.Color, title: "Marker", defaultValue: dp.markerColor }, isDraggable: { type: ControlType.Boolean, title: "Draggable", defaultValue: dp.isDraggable }, dragOptions: { type: ControlType.Object, title: "Transition", controls: { stiffness: { type: ControlType.Number, min: 0, max: 1e3, title: "Stiffness", defaultValue: dpDrag.stiffness }, damping: { type: ControlType.Number, min: 0, max: 100, title: "Damping", defaultValue: dpDrag.damping }, mass: { type: ControlType.Number, min: 0, title: "Mass", displayStepper: true, defaultValue: dpDrag.mass } }, hidden(props) {
  return !props.isDraggable;
} }, speed: { type: ControlType.Number, min: 0, step: 0.1, displayStepper: true, title: "Speed", defaultValue: dp.speed }, phi: { type: ControlType.Number, min: 0, max: 6.28, step: 0.01, displayStepper: true, title: "Phi", defaultValue: dp.phi }, theta: { type: ControlType.Number, min: -1.57, max: 1.57, step: 0.01, title: "Theta", defaultValue: dp.theta }, dark: { type: ControlType.Number, min: 0, max: 1, step: 0.1, displayStepper: true, title: "Dark", defaultValue: dp.dark }, diffuse: { type: ControlType.Number, min: 0, max: 5, step: 0.01, title: "Diffuse", defaultValue: dp.diffuse }, mapBrightness: { type: ControlType.Number, min: 0, max: 12, step: 0.01, title: "Brightness", defaultValue: dp.mapBrightness }, maxSamples: { type: ControlType.Number, min: 0, max: 1e5, title: "Samples", defaultValue: dp.maxSamples }, scale: { type: ControlType.Number, min: 0, max: 5, step: 0.025, displayStepper: true, title: "Scale", defaultValue: dp.scale }, alignment: { type: ControlType.Enum, title: "Align", options: ["flex-start", "center", "flex-end"], optionIcons: ["align-top", "align-middle", "align-bottom"], defaultValue: dp.alignment, displaySegmentedControl: true }, maxWidth: { type: ControlType.Number, title: "Max Width", min: 100, max: 5e3, defaultValue: dp.maxWidth }, offset: { type: ControlType.Object, title: "Offset", controls: { offsetX: { type: ControlType.Number, min: -5e3, max: 5e3, title: "X", defaultValue: dpOffset.offsetX }, offsetY: { type: ControlType.Number, min: -5e3, max: 5e3, title: "Y", defaultValue: dpOffset.offsetY } } }, markerSize: { type: ControlType.Number, min: 0, max: 1, step: 0.01, title: "Markers", defaultValue: dp.markerSize }, markerArray: {
  type: ControlType.Array,
  title: "Location",
  // defaultValue: [{ latitude: 52.3676, longitude: 4.9041 }],
  control: { type: ControlType.Object, title: "Location", controls: { latitude: { type: ControlType.Number, min: -90, max: 90, title: "Lat", step: 1e-4, defaultValue: dp.markerArray.latitude }, longitude: { type: ControlType.Number, min: -180, max: 180, title: "Long", step: 1e-4, defaultValue: dp.markerArray.longitude } } }
} });
var flexStyles = { width: "100%", height: "100%", display: "flex", placeItems: "center", placeContent: "center", overflow: "visible" };
var convertRGB = (color) => {
  return { r: Color(color).r / 255, g: Color(color).g / 255, b: Color(color).b / 255 };
};

export {
  Globe
};
