// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 61763921e49c2823 "Suprema (copy)", do not edit manually */
import {
  defaultEvents,
  useOnEnter,
  useOnExit
} from "./chunk-UHJVU4UO.js";

// /:https://framerusercontent.com/modules/NQ9LlTfXzHTRhTTi6qMI/5u9VoSaQM7qxLI2scUcH/Loading.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from "react";
import { useRef, useEffect } from "react";
import { addPropertyControls, ControlType, useAnimation, motion } from "unframer";
var Indicators;
(function(Indicators2) {
  Indicators2["DotWave"] = "Dots";
  Indicators2["Material"] = "Material";
  Indicators2["IOS"] = "iOS";
})(Indicators || (Indicators = {}));
function DotWave({ color, animation }) {
  const circles = [0, 1, 2];
  const { delay, ease, duration, ...animProps } = animation;
  const transition = animation.type === "spring" ? animProps : { ...animProps, ease, duration };
  return /* @__PURE__ */ _jsx(motion.svg, { style: { height: "85%", width: "85%" }, viewBox: "0 0 30 30", variants: { show: { transition: { delayChildren: 0.1, staggerChildren: 0.12 } } }, animate: "show", children: circles.map((circle) => /* @__PURE__ */ _jsx(motion.circle, { style: { fill: color }, variants: { hidden: { y: 0 }, show: { y: [0, 0, 0, -10, 0, 0, 0] } }, transition: { ...transition, yoyo: Infinity }, r: 3, cx: circle * 10 + 5, cy: 15 }, circle)) });
}
function Material({ color, animation }) {
  return /* @__PURE__ */ _jsx(motion.svg, { style: { height: "85%", width: "85%", overflow: "visible", originX: "50%", originY: "50%" }, animate: { rotate: 360 }, transition: { ease: "linear", loop: Infinity, duration: 2 }, viewBox: "25 25 50 50", children: /* @__PURE__ */ _jsx(motion.circle, { style: { stroke: color, strokeLinecap: "round" }, animate: { strokeDasharray: ["1, 200", "89, 200", "89, 200"], strokeDashoffset: [0, -35, -124] }, transition: { ...animation, loop: Infinity, ease: "easeInOut" }, cx: "50", cy: "50", r: "20", fill: "none", strokeWidth: 2, strokeMiterlimit: "10" }) });
}
function IOS({ color, animation }) {
  const particles = 12;
  const arrayRotate = (arr, n) => arr.slice(n, arr.length).concat(arr.slice(0, n));
  const lines = [...new Array(particles)].map((l, i) => 0.9 / particles * i + 0.1).reverse();
  const lineOpacities = lines.map((l, i) => arrayRotate(lines, i));
  return /* @__PURE__ */ _jsx(motion.svg, { viewBox: "-15 -15 30 30", style: { width: "100%", height: "100%" }, children: lineOpacities.map((lineKeyframes, i) => /* @__PURE__ */ _jsx(motion.g, { initial: { opacity: lineKeyframes[0] }, animate: { opacity: lineKeyframes }, transition: { ...animation, loop: Infinity, repeatDelay: 5e-4 }, children: /* @__PURE__ */ _jsx("rect", { style: { width: 7, height: 2, fill: color, transform: `rotate(${(particles - i) / particles * 360 - 90}deg)` }, x: 5, y: -1, rx: 1 }) }, i)) });
}
function getIndicator(indicator, props) {
  switch (indicator) {
    case Indicators.DotWave:
      return /* @__PURE__ */ _jsx(DotWave, { ...props });
    case Indicators.Material:
      return /* @__PURE__ */ _jsx(Material, { ...props });
    case Indicators.IOS:
      return /* @__PURE__ */ _jsx(IOS, { ...props });
    // case Indicators.Spinner:
    //     return <Spinner {...props} />
    default:
      return /* @__PURE__ */ _jsx(DotWave, { ...props });
  }
}
function handleTimeout(duration, callback) {
  const id = setTimeout(callback, duration * 1e3);
  return () => clearTimeout(id);
}
function Loading(props) {
  const { duration, onTimeout, fadeOut, hasDuration, indicator, onClick, onMouseDown, onMouseUp, onMouseEnter, onMouseLeave, style } = props;
  const controls = useAnimation();
  const animDuration = fadeOut ? Math.min(duration, 0.35) : 0;
  const animDelay = fadeOut ? duration - animDuration : duration;
  const currentIndicator = getIndicator(indicator, props);
  const handlers = useRef([]);
  const onFadeOut = React.useCallback(() => {
    if (hasDuration) controls.start({ opacity: 0, transition: { duration: animDuration, ease: "easeIn" } });
  }, [hasDuration, animDuration]);
  const resetOpacity = async () => {
    controls.set({ opacity: 1 });
  };
  useOnEnter(() => {
    resetOpacity();
    if (hasDuration) handlers.current = [handleTimeout(duration, onTimeout), handleTimeout(animDelay, onFadeOut)];
  });
  useOnExit(() => handlers.current.forEach((cleanup) => cleanup));
  useEffect(() => () => handlers.current.forEach((cleanup) => cleanup), []);
  return /* @__PURE__ */ _jsx(motion.div, { onClick, onMouseDown, onMouseUp, onMouseEnter, onMouseLeave, animate: controls, style: { position: "relative", overflow: "show", display: "flex", justifyContent: "center", alignItems: "center", ...style }, children: currentIndicator });
}
Loading.defaultProps = { height: 40, width: 40, duration: 2, color: "#888", animation: { type: "tween", ease: "linear", duration: 1.3 }, hasDuration: false };
addPropertyControls(Loading, {
  indicator: { title: "Indicator", type: ControlType.Enum, options: Object.keys(Indicators).map((i) => Indicators[i]) },
  color: { type: ControlType.Color, defaultValue: "#888" },
  // transition: { title: "Animation", type: ControlType.Transition },
  hasDuration: { title: "Duration", type: ControlType.Boolean, defaultValue: Loading.defaultProps.hasDuration, enabledTitle: "Timeout", disabledTitle: "Infinity" },
  duration: { title: "Time", hidden: ({ hasDuration }) => !hasDuration, min: 0.1, max: 10, defaultValue: Loading.defaultProps.duration, type: ControlType.Number, step: 0.1 },
  animation: { type: ControlType.Transition },
  fadeOut: { title: "Fade Out", hidden: ({ hasDuration }) => !hasDuration, type: ControlType.Boolean, enabledTitle: "Yes", disabledTitle: "No" },
  onTimeout: { type: ControlType.EventHandler },
  ...defaultEvents
});

export {
  Loading
};
